
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Azure IoT Edge &#43; Kubernetes</title>
  <script src="../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Azure IoT Edge &#43; Kubernetes"
                  environment="web"
                  feedback-link="https://github.com/avranju/iotedge-k8s/issues">
    
      <google-codelab-step label="Introduction" duration="0">
        <p>Azure IoT Edge now features integration with the Kubernetes orchestration engine. The primary purpose of this integration at this time is to achieve high availability. If you&#39;d like to read a document that goes into some detail of how this implementation works, you&#39;ll find it <a href="https://microsoft-my.sharepoint.com/:w:/p/rajave/EVTttp24fZJMv206fqHybisBZ-LKWLlYwqi1VAfp5H8QQQ?e=CdkZ9e" target="_blank">here</a> (please email <a href="mailto:rajave@microsoft.com" target="_blank"><strong>rajave@microsoft.com</strong></a><strong> </strong>in case you don&#39;t have access).</p>
<p>This document walks you through a test drive of this integration.</p>
<h2><strong>What you will need</strong></h2>
<h3><strong>Access to a Kubernetes cluster</strong></h3>
<p>If you don&#39;t have a cluster handy, you can easily create one for yourself using the <a href="https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough" target="_blank">Azure Kubernetes Service</a>.</p>
<h3><strong>Install Helm</strong></h3>
<p>Install the Helm CLI on your PC and Tiller on your cluster. The <a href="https://docs.helm.sh/using_helm/#quickstart" target="_blank">Helm quickstart</a> has all the information you need to get things going.</p>
<aside class="warning"><p><strong>Important</strong>: Pay attention to the <a href="https://docs.helm.sh/using_helm/#understand-your-security-context" target="_blank">security context</a> bit when setting up Helm because Kubernetes clusters these days come with Role-Based Access Control (RBAC) enabled by default. If that is the case with your cluster then you may need to setup a service account which has the required access rules setup so that Helm is able to administer your cluster.</p>
</aside>
<p>If you&#39;re short on time however, here&#39;s the quick â€˜n&#39; dirty guide to getting Helm (v2.12.1) setup on a Linux box (these instructions should work on a Windows box as well when used with <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank">WSL</a>):</p>
<ol type="1" start="1">
<li>Download the Helm binary (this example downloads the Linux x64 version - you may want to pick the right URL that applies to you from the Helm project&#39;s <a href="https://github.com/helm/helm/releases" target="_blank"><em>Releases</em></a> page):</li>
</ol>
<pre>wget https://storage.googleapis.com/kubernetes-helm/helm-v2.12.1-linux-amd64.tar.gz</pre>
<ol type="1" start="2">
<li>Extract the gzip file:</li>
</ol>
<pre>tar xzf helm-v2.12.1-linux-amd64.tar.gz &amp;&amp; cd linux-amd64</pre>
<ol type="1" start="3">
<li>Create a YAML file for creating a service account for running Tiller:</li>
</ol>
<pre><code>cat &gt; helm-rbac.yaml &lt;&lt;EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
        name: tiller
        namespace: kube-system
EOF</code></pre>
<ol type="1" start="4">
<li>Create the service account:</li>
</ol>
<pre>kubectl apply -f ./helm-rbac.yaml</pre>
<ol type="1" start="5">
<li>Install Tiller in your cluster:</li>
</ol>
<pre>helm init --service-account tiller</pre>
<aside class="warning"><p><strong>Important</strong>: If you are installing Helm in an ARM32v7 cluster then you&#39;ll want to use the following command instead:</p>
<p><code>helm init --service-account tiller --tiller-image azureiotedge/tiller:2.12.1-linux-arm32v7</code></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Add Edge helm repo to your installation" duration="0">
        <p>Add the Edge Helm repository to your helm CLI by running the following command:</p>
<pre>helm repo add edgek8s https://edgek8s.blob.core.windows.net/helm/</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Install iotedged and Edge Agent to your cluster" duration="0">
        <p>Deploy the <strong>iotedged</strong> and <strong>Edge Agent</strong> pods in your Kubernetes cluster by installing the Edge Helm chart like so:</p>
<pre>helm install \
  --name edgy \
  --set &#34;deviceConnectionString=&lt;DEVICE CONNECTION STRING HERE&gt;&#34; \
  edgek8s/edge-kubernetes</pre>
<aside class="warning"><p><strong>Important</strong>: Note that this deploys <strong>iotedged</strong> in &#34;QuickStart&#34; mode which means that <strong>iotedged</strong> will use a self-signed device CA cert for generating server and identity certificates. This device CA cert expires after 90 days.</p>
<p>Also, this will cause <strong>iotedged</strong> to use the container file system to store the certificate files and the master encryption key. This will not work very well in case the <strong>iotedged</strong> pod gets re-created by Kubernetes as it will end up generating brand new certificates and encryption keys thereby disabling all existing modules. Please see the section titled &#34;<em>Persistent storage for iotedged</em>&#34; to learn how this can be dealt with.</p>
</aside>
<p>At this point your cluster is ready to receive Edge deployments.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Deploy your Edge modules" duration="0">
        <p>You can deploy your Edge modules in Azure IoT Hub as usual except for the following important caveat:</p>
<aside class="special"><p>Use the following container image for the Edge Agent module:</p>
</aside>
<pre>azureiotedge/azureiotedge-agent:0.1.0-alpha</pre>
<p>A significant part of the Kubernetes integration code lives in the custom Edge Agent module image shown above. If you use the Edge Agent image that one normally uses (from the <em>mcr.microsoft.com</em> registry) then it won&#39;t work.</p>
<p>All of the Edge specific resources are deployed in Kubernetes in a namespace called <code>microsoft-azure-devices-edge</code>. You can keep an eye on the pods as they get deployed by running:</p>
<pre>kubectl get pods -n microsoft-azure-devices-edge -w</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Persistent storage for iotedged" duration="0">
        <p>In order to gain HA benefits, you&#39;ll want to run <strong>iotedged</strong> with persistent storage attached to it instead of using the transient container file system. You can do this by doing the following:</p>
<ol type="1" start="1">
<li>Create a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank">persistent volume</a> in your cluster</li>
<li>Deploy <strong>iotedged</strong> and <strong>Edge Agent</strong> specifying a persistent volume claim name (<code>iotedged-pvc</code> below) like so:</li>
</ol>
<pre>helm install \
  --name edgy \
  --set &#34;&lt;DEVICE CONNECTION STRING HERE&gt;&#34; \
  --set &#34;iotedged.data.persistentVolumeClaim.claimName=iotedged-pvc&#34; \
  edgek8s/edge-kubernetes</pre>
<ol type="1" start="3">
<li>Create the persistent volume claim (PVC) with the same name (<code>iotedged-pvc</code> if you used the example above).  Here&#39;s a sample YAML you might use. Please note that you&#39;ll want to use the right value for the <strong>storageClassName</strong> attribute depending on what your persistent volume supports. Also, your PVC needs to be created in the namespace <strong>microsoft-azure-devices-edge</strong>.</li>
</ol>
<pre><code>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: iotedged-pvc
  namespace: microsoft-azure-devices-edge
spec:
  resources:
        requests:
          storage: 1Gi
  accessModes:
        - ReadWriteMany
  storageClassName: standard</code></pre>
<p>Note that these steps need to be done in the sequence given above because the PVC needs to be created in the same namespace as the other resources (the namespace being <strong>microsoft-azure-devices-edge</strong>) and the namespace itself is created when the helm chart is installed.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Clean up" duration="0">
        <p>Assuming <code>edgy</code> is the name you used when running <code>helm install</code>, all deployed resources can be deleted by running:</p>
<pre>helm delete --purge edgy</pre>
<h2><strong>Really really clean up</strong></h2>
<p>It is possible that you may sometimes run into a situation where helm gets into a bad state and is unable to fully remove the installation (especially if you repeatedly install/uninstall the helm chart and interrupt in the middle and so forth). If this occurs, then the following commands should get rid of the deployments:</p>
<pre>kubectl delete namespace microsoft-azure-devices-edge
kubectl delete configmap -n kube-system edgy.v1</pre>
<p>After this, running <code>helm ls --all</code> should no longer show the edge installation.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Resources" duration="0">
        <h2><strong>Source</strong></h2>
<p>The source code for the Kubernetes integration work lives here:</p>
<aside class="special"><p><a href="https://github.com/avranju/iotedge-k8s/tree/edgelet-k8s" target="_blank">https://github.com/avranju/iotedge-k8s/tree/edgelet-k8s</a></p>
</aside>
<p>You&#39;ll find the Helm chart definition <a href="https://github.com/avranju/iotedge-k8s/tree/edgelet-k8s/edgelet/build/charts/edge-kubernetes" target="_blank">here</a> and all the customization options can be specified via a <code>values.yaml</code> file as documented <a href="https://github.com/avranju/iotedge-k8s/blob/edgelet-k8s/edgelet/build/charts/edge-kubernetes/values.yaml" target="_blank">here</a>.</p>
<h2><strong>Issues</strong></h2>
<p>If you&#39;d like to file issues, please use GitHub on the same repo (we&#39;ll figure out a better place to file these by the time we go more public with this preview):</p>
<aside class="special"><p><a href="https://github.com/avranju/iotedge-k8s/issues" target="_blank">https://github.com/avranju/iotedge-k8s/issues</a></p>
</aside>
<h2><strong>Support</strong></h2>
<p>If you are stuck, please feel free to reach out to any (or all) of the following aliases:</p>
<ul>
<li>rajave</li>
<li>darobs</li>
<li>veyalla</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49880327-14', 'auto');

    (function() {
      var gaCodelab = '';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
